code structure

// === Project Structure: TypeScript version ===
// server/
// ├── controllers/
// ├── models/
// ├── routes/
// ├── sockets/
// ├── middlewares/
// ├── utils/
// ├── app.ts
// └── server.ts

// client/
// ├── public/
// ├── src/
// │   ├── components/
// │   ├── pages/
// │   ├── App.tsx
// │   └── index.tsx
// └── tsconfig.json

// === BACKEND CODE (TypeScript) ===

// server/app.ts
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import authRoutes from './routes/auth';
import noteRoutes from './routes/notes';
import chatRoutes from './routes/chat';
import { verifyToken } from './middlewares/auth';

const app = express();
app.use(cors({ origin: true, credentials: true }));
app.use(express.json());
app.use(cookieParser());

app.use('/api/auth', authRoutes);
app.use('/api/notes', verifyToken, noteRoutes);
app.use('/api/chat', verifyToken, chatRoutes);

export default app;

// server/server.ts
import http from 'http';
import app from './app';
import mongoose from 'mongoose';
import { setupSocket } from './sockets/socket';

const server = http.createServer(app);
setupSocket(server);

mongoose.connect('mongodb://localhost:27017/collabnotes')
  .then(() => server.listen(5000, () => console.log('Server running on port 5000')))
  .catch(err => console.error(err));

// server/models/User.ts
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';

export interface IUser extends mongoose.Document {
  username: string;
  password: string;
}

const userSchema = new mongoose.Schema<IUser>({
  username: { type: String, required: true },
  password: { type: String, required: true }
});

userSchema.pre('save', async function (next) {
  const user = this as IUser;
  if (user.isModified('password')) {
    user.password = await bcrypt.hash(user.password, 10);
  }
  next();
});

export default mongoose.model<IUser>('User', userSchema);

// server/models/Note.ts
import mongoose from 'mongoose';

export interface INote extends mongoose.Document {
  title: string;
  content: string;
  sharedWith: string[];
  labels: string[];
  archived: boolean;
  pinned: boolean;
  updatedAt: Date;
  owner: string;
}

const noteSchema = new mongoose.Schema<INote>({
  title: String,
  content: String,
  sharedWith: [String],
  labels: [String],
  archived: Boolean,
  pinned: Boolean,
  updatedAt: Date,
  owner: String
});

export default mongoose.model<INote>('Note', noteSchema);

// server/routes/auth.ts
import express from 'express';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import User from '../models/User';

const router = express.Router();

router.post('/register', async (req, res) => {
  try {
    const user = new User(req.body);
    await user.save();
    res.sendStatus(201);
  } catch (err) {
    res.status(500).send('Error registering user');
  }
});

router.post('/login', async (req, res) => {
  const user = await User.findOne({ username: req.body.username });
  if (!user || !(await bcrypt.compare(req.body.password, user.password))) {
    return res.status(401).send('Invalid credentials');
  }
  const token = jwt.sign({ username: user.username }, 'secret');
  res.json({ token });
});

export default router;

// server/middlewares/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

declare global {
  namespace Express {
    interface Request {
      user?: any;
    }
  }
}

export function verifyToken(req: Request, res: Response, next: NextFunction) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.sendStatus(403);
  try {
    req.user = jwt.verify(token, 'secret');
    next();
  } catch {
    res.sendStatus(403);
  }
}

// server/routes/notes.ts
import express from 'express';
import Note from '../models/Note';

const router = express.Router();

router.get('/', async (req, res) => {
  const notes = await Note.find({ owner: req.user?.username });
  res.json(notes);
});

router.post('/', async (req, res) => {
  const note = new Note({ ...req.body, owner: req.user?.username, updatedAt: new Date() });
  await note.save();
  res.sendStatus(201);
});

router.put('/bulk', async (req, res) => {
  const { ids, updates } = req.body;
  await Note.updateMany({ _id: { $in: ids }, owner: req.user?.username }, { $set: updates });
  res.sendStatus(200);
});

export default router;

// server/sockets/socket.ts
import { Server } from 'socket.io';
import jwt from 'jsonwebtoken';
import { Server as HTTPServer } from 'http';

export function setupSocket(server: HTTPServer) {
  const io = new Server(server, { cors: { origin: '*' } });

  io.use((socket, next) => {
    const token = socket.handshake.auth.token;
    try {
      socket.data.user = jwt.verify(token, 'secret');
      next();
    } catch {
      next(new Error('Auth error'));
    }
  });

  io.on('connection', socket => {
    socket.on('join', (room: string) => socket.join(room));
    socket.on('message', ({ room, message }) => {
      io.to(room).emit('message', { user: socket.data.user.username, message });
    });
  });
}

// === FRONTEND CODE (React + JSX + TypeScript, No Vite) ===

// client/src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);

// client/src/App.tsx
import React, { useEffect, useState } from 'react';
import { io, Socket } from 'socket.io-client';

interface ChatMessage {
  user: string;
  message: string;
}

const socket: Socket = io('http://localhost:5000', {
  auth: { token: localStorage.getItem('token') || '' }
});

const App: React.FC = () => {
  const [message, setMessage] = useState('');
  const [chat, setChat] = useState<ChatMessage[]>([]);

  useEffect(() => {
    socket.on('message', (data: ChatMessage) => {
      setChat(prev => [...prev, data]);
    });
  }, []);

  return (
    <div>
      <h1>Chat</h1>
      <div>
        {chat.map((c, i) => (
          <p key={i}><b>{c.user}:</b> {c.message}</p>
        ))}
      </div>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={() => socket.emit('message', { room: 'main', message })}>Send</button>
    </div>
  );
};

export default App;
